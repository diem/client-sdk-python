<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>diem.txnmetadata API documentation</title>
<meta name="description" content="LIP-4 Transaction Metadata Utilities …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>diem.txnmetadata</code></h1>
</header>
<section id="section-intro">
<p>LIP-4 Transaction Metadata Utilities</p>
<p>This module implements utility functions for application to create transaction metadata and metadata signature.
See <a href="https://dip.diem.com/dip-4">https://dip.diem.com/dip-4</a> for more details</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) The Diem Core Contributors
# SPDX-License-Identifier: Apache-2.0


&#34;&#34;&#34;LIP-4 Transaction Metadata Utilities

This module implements utility functions for application to create transaction metadata and metadata signature.
See https://dip.diem.com/dip-4 for more details
&#34;&#34;&#34;


from dataclasses import dataclass
import typing, warnings

from . import diem_types, serde_types, bcs, jsonrpc, utils


class InvalidEventMetadataForRefundError(Exception):
    pass


@dataclass
class Attest:

    metadata: diem_types.Metadata
    sender_address: diem_types.AccountAddress
    amount: serde_types.uint64  # pyre-ignore

    def bcs_serialize(self) -&gt; bytes:
        return bcs.serialize(self, Attest)


def travel_rule(
    off_chain_reference_id: str, sender_address: diem_types.AccountAddress, amount: int
) -&gt; typing.Tuple[bytes, bytes]:
    &#34;&#34;&#34;Create travel rule metadata bytes and signature message bytes.

    This is used for peer to peer transfer between 2 custodial accounts.
    &#34;&#34;&#34;

    metadata = diem_types.Metadata__TravelRuleMetadata(
        value=diem_types.TravelRuleMetadata__TravelRuleMetadataVersion0(
            value=diem_types.TravelRuleMetadataV0(off_chain_reference_id=off_chain_reference_id)
        )
    )

    # receiver_bcs_data = bcs(metadata, sender_address, amount) + &#34;@@$$DIEM_ATTEST$$@@&#34; /*ASCII-encoded string*/
    attest = Attest(metadata=metadata, sender_address=sender_address, amount=serde_types.uint64(amount))  # pyre-ignore
    signing_msg = attest.bcs_serialize() + b&#34;@@$$DIEM_ATTEST$$@@&#34;

    return (metadata.bcs_serialize(), signing_msg)


def decode_structure(
    bytes_or_str: typing.Union[bytes, str]
) -&gt; typing.Union[None, diem_types.GeneralMetadataV0, diem_types.TravelRuleMetadataV0, diem_types.RefundMetadataV0]:
    &#34;&#34;&#34;Decode given metadata bytes of string into structure types

    Returns None if:
    1. given param is empty or None
    2. metadata type is non-structured or undefined
    &#34;&#34;&#34;

    if not bytes_or_str:
        return None
    b = bytes_or_str if isinstance(bytes_or_str, bytes) else bytes.fromhex(bytes_or_str)
    try:
        metadata = diem_types.Metadata.bcs_deserialize(b)
        return metadata.decode_structure()
    except serde_types.DeserializationError:
        return None


def refund_metadata(original_transaction_version: int, reason: diem_types.RefundReason) -&gt; bytes:
    &#34;&#34;&#34;Create refund metadata for peer to peer transaction script

    Use this function to create metadata when refunding a transaction, pass in the transaction version and
    a reason.

    List of reason types available:

    0. RefundReason__OtherReason
    1. RefundReason__InvalidSubaddress,
    2. RefundReason__UserInitiatedPartialRefund,
    3. RefundReason__UserInitiatedFullRefund,

    Example:

    ```
    &gt;&gt;&gt; from diem import diem_types, txnmetadata
    &gt;&gt;&gt; txnmetadata.refund_metadata(txn_version, diem_types.RefundReason__UserInitiatedFullRefund())

    &#34;&#34;&#34;

    metadata = diem_types.Metadata__RefundMetadata(
        value=diem_types.RefundMetadata__RefundMetadataV0(
            value=diem_types.RefundMetadataV0(  # pyre-ignore
                transaction_version=original_transaction_version, reason=reason
            )
        )
    )
    return metadata.bcs_serialize()


def coin_trade_metadata(trade_ids: typing.List[str]) -&gt; bytes:
    &#34;&#34;&#34;Create `diem_types.Metadata__CoinTradeMetadata` with `diem_types.CoinTradeMetadataV0`&#34;&#34;&#34;

    metadata = diem_types.Metadata__CoinTradeMetadata(
        value=diem_types.CoinTradeMetadata__CoinTradeMetadataV0(
            value=diem_types.CoinTradeMetadataV0(trade_ids=trade_ids)
        )
    )
    return metadata.bcs_serialize()


def general_metadata(
    from_subaddress: typing.Optional[bytes] = None,
    to_subaddress: typing.Optional[bytes] = None,
    referenced_event: typing.Optional[int] = None,
) -&gt; bytes:
    &#34;&#34;&#34;Create general metadata for peer to peer transaction script

    Use this function to create metadata with from and to sub-addresses for peer to peer transfer
    from custodial account to custodial account under travel rule threshold.

    Give from_subaddress None for the case transferring from non-custodial to custodial account.
    Give to_subaddress None for the case transferring from custodial to non-custodial account.
    &#34;&#34;&#34;

    metadata = diem_types.Metadata__GeneralMetadata(
        value=diem_types.GeneralMetadata__GeneralMetadataVersion0(
            value=diem_types.GeneralMetadataV0(  # pyre-ignore
                from_subaddress=from_subaddress,
                to_subaddress=to_subaddress,
                referenced_event=serde_types.uint64(referenced_event) if referenced_event else None,
            )
        )
    )
    return metadata.bcs_serialize()


def find_refund_reference_event(
    txn: typing.Optional[jsonrpc.Transaction], receiver: typing.Union[diem_types.AccountAddress, str]
) -&gt; typing.Optional[jsonrpc.Event]:
    &#34;&#34;&#34;Find refund reference event from given transaction

    The event can be used as reference is the &#34;receivedpayment&#34; event.
    We also only return event that receiver address matches given reciever address, because
    it is possible we may have mutliple receivers for one transaction in the future.

    Returns None if given transaction is None or the event not found.
    If this function returns an event, then you may call `refund_metadata_from_event` function
    to create refund metadata for the refund transaction.
    &#34;&#34;&#34;

    if txn is None:
        return None

    address = utils.account_address_hex(receiver)
    for event in txn.events:
        if event.data.type == &#34;receivedpayment&#34; and event.data.receiver == address:
            return event

    return None


def refund_metadata_from_event(event: jsonrpc.Event) -&gt; typing.Optional[bytes]:
    &#34;&#34;&#34;create refund metadat for the event

    The given event should be the reference event for the refund, it should have metadata describes
    the payment details.
    May call `find_refund_reference_event` function to find reference event from a peer to peer transfer
    transaction.

    Returns empty bytes array if given event metadata is None or empty string, this is for the case
    the peer to peer transaction is a non-custodial to non-custodial account, which does not require
    metadata, hence the refund transaction should not have metadata too.

    Raises InvalidEventMetadataForRefundError if metadata can&#39;t be decoded as
    diem_types.GeneralMetadata__GeneralMetadataVersion0 for creating the refund metadata
    &#34;&#34;&#34;

    warnings.warn(
        &#34;`refund_metadata_from_event` is deprecated, prefer `refund_metadata` to create `diem_types.Metadata__RefundMetadata` BCS serialized bytes&#34;
    )

    if not event.data.metadata:
        return b&#34;&#34;

    try:
        metadata_bytes = bytes.fromhex(event.data.metadata)
        metadata = diem_types.Metadata.bcs_deserialize(metadata_bytes)

        if isinstance(metadata, diem_types.Metadata__GeneralMetadata):
            if isinstance(metadata.value, diem_types.GeneralMetadata__GeneralMetadataVersion0):
                gmv0 = metadata.value.value
                return general_metadata(gmv0.to_subaddress, gmv0.from_subaddress, event.sequence_number)

            raise InvalidEventMetadataForRefundError(&#34;unknown metadata type: {metadata}&#34;)

        raise InvalidEventMetadataForRefundError(f&#34;unknown metadata type: {metadata}&#34;)
    except ValueError as e:
        raise InvalidEventMetadataForRefundError(f&#34;invalid event metadata for refund: {e}, event: {event}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="diem.txnmetadata.coin_trade_metadata"><code class="name flex">
<span>def <span class="ident">coin_trade_metadata</span></span>(<span>trade_ids: List[str]) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Create <code>diem_types.Metadata__CoinTradeMetadata</code> with <code>diem_types.CoinTradeMetadataV0</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coin_trade_metadata(trade_ids: typing.List[str]) -&gt; bytes:
    &#34;&#34;&#34;Create `diem_types.Metadata__CoinTradeMetadata` with `diem_types.CoinTradeMetadataV0`&#34;&#34;&#34;

    metadata = diem_types.Metadata__CoinTradeMetadata(
        value=diem_types.CoinTradeMetadata__CoinTradeMetadataV0(
            value=diem_types.CoinTradeMetadataV0(trade_ids=trade_ids)
        )
    )
    return metadata.bcs_serialize()</code></pre>
</details>
</dd>
<dt id="diem.txnmetadata.decode_structure"><code class="name flex">
<span>def <span class="ident">decode_structure</span></span>(<span>bytes_or_str: Union[bytes, str]) ‑> Union[NoneType, <a title="diem.diem_types.GeneralMetadataV0" href="diem_types/index.html#diem.diem_types.GeneralMetadataV0">GeneralMetadataV0</a>, <a title="diem.diem_types.TravelRuleMetadataV0" href="diem_types/index.html#diem.diem_types.TravelRuleMetadataV0">TravelRuleMetadataV0</a>, <a title="diem.diem_types.RefundMetadataV0" href="diem_types/index.html#diem.diem_types.RefundMetadataV0">RefundMetadataV0</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Decode given metadata bytes of string into structure types</p>
<p>Returns None if:
1. given param is empty or None
2. metadata type is non-structured or undefined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_structure(
    bytes_or_str: typing.Union[bytes, str]
) -&gt; typing.Union[None, diem_types.GeneralMetadataV0, diem_types.TravelRuleMetadataV0, diem_types.RefundMetadataV0]:
    &#34;&#34;&#34;Decode given metadata bytes of string into structure types

    Returns None if:
    1. given param is empty or None
    2. metadata type is non-structured or undefined
    &#34;&#34;&#34;

    if not bytes_or_str:
        return None
    b = bytes_or_str if isinstance(bytes_or_str, bytes) else bytes.fromhex(bytes_or_str)
    try:
        metadata = diem_types.Metadata.bcs_deserialize(b)
        return metadata.decode_structure()
    except serde_types.DeserializationError:
        return None</code></pre>
</details>
</dd>
<dt id="diem.txnmetadata.find_refund_reference_event"><code class="name flex">
<span>def <span class="ident">find_refund_reference_event</span></span>(<span>txn: Optional[jsonrpc_pb2.Transaction], receiver: Union[<a title="diem.diem_types.AccountAddress" href="diem_types/index.html#diem.diem_types.AccountAddress">AccountAddress</a>, str]) ‑> Optional[jsonrpc_pb2.Event]</span>
</code></dt>
<dd>
<div class="desc"><p>Find refund reference event from given transaction</p>
<p>The event can be used as reference is the "receivedpayment" event.
We also only return event that receiver address matches given reciever address, because
it is possible we may have mutliple receivers for one transaction in the future.</p>
<p>Returns None if given transaction is None or the event not found.
If this function returns an event, then you may call <code><a title="diem.txnmetadata.refund_metadata_from_event" href="#diem.txnmetadata.refund_metadata_from_event">refund_metadata_from_event()</a></code> function
to create refund metadata for the refund transaction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_refund_reference_event(
    txn: typing.Optional[jsonrpc.Transaction], receiver: typing.Union[diem_types.AccountAddress, str]
) -&gt; typing.Optional[jsonrpc.Event]:
    &#34;&#34;&#34;Find refund reference event from given transaction

    The event can be used as reference is the &#34;receivedpayment&#34; event.
    We also only return event that receiver address matches given reciever address, because
    it is possible we may have mutliple receivers for one transaction in the future.

    Returns None if given transaction is None or the event not found.
    If this function returns an event, then you may call `refund_metadata_from_event` function
    to create refund metadata for the refund transaction.
    &#34;&#34;&#34;

    if txn is None:
        return None

    address = utils.account_address_hex(receiver)
    for event in txn.events:
        if event.data.type == &#34;receivedpayment&#34; and event.data.receiver == address:
            return event

    return None</code></pre>
</details>
</dd>
<dt id="diem.txnmetadata.general_metadata"><code class="name flex">
<span>def <span class="ident">general_metadata</span></span>(<span>from_subaddress: Optional[bytes] = None, to_subaddress: Optional[bytes] = None, referenced_event: Optional[int] = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Create general metadata for peer to peer transaction script</p>
<p>Use this function to create metadata with from and to sub-addresses for peer to peer transfer
from custodial account to custodial account under travel rule threshold.</p>
<p>Give from_subaddress None for the case transferring from non-custodial to custodial account.
Give to_subaddress None for the case transferring from custodial to non-custodial account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def general_metadata(
    from_subaddress: typing.Optional[bytes] = None,
    to_subaddress: typing.Optional[bytes] = None,
    referenced_event: typing.Optional[int] = None,
) -&gt; bytes:
    &#34;&#34;&#34;Create general metadata for peer to peer transaction script

    Use this function to create metadata with from and to sub-addresses for peer to peer transfer
    from custodial account to custodial account under travel rule threshold.

    Give from_subaddress None for the case transferring from non-custodial to custodial account.
    Give to_subaddress None for the case transferring from custodial to non-custodial account.
    &#34;&#34;&#34;

    metadata = diem_types.Metadata__GeneralMetadata(
        value=diem_types.GeneralMetadata__GeneralMetadataVersion0(
            value=diem_types.GeneralMetadataV0(  # pyre-ignore
                from_subaddress=from_subaddress,
                to_subaddress=to_subaddress,
                referenced_event=serde_types.uint64(referenced_event) if referenced_event else None,
            )
        )
    )
    return metadata.bcs_serialize()</code></pre>
</details>
</dd>
<dt id="diem.txnmetadata.refund_metadata"><code class="name flex">
<span>def <span class="ident">refund_metadata</span></span>(<span>original_transaction_version: int, reason: <a title="diem.diem_types.RefundReason" href="diem_types/index.html#diem.diem_types.RefundReason">RefundReason</a>) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Create refund metadata for peer to peer transaction script</p>
<p>Use this function to create metadata when refunding a transaction, pass in the transaction version and
a reason.</p>
<p>List of reason types available:</p>
<ol>
<li>RefundReason__OtherReason</li>
<li>RefundReason__InvalidSubaddress,</li>
<li>RefundReason__UserInitiatedPartialRefund,</li>
<li>RefundReason__UserInitiatedFullRefund,</li>
</ol>
<p>Example:</p>
<pre><code>```python-repl
&gt;&gt;&gt; from diem import diem_types, txnmetadata
&gt;&gt;&gt; txnmetadata.refund_metadata(txn_version, diem_types.RefundReason__UserInitiatedFullRefund())
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refund_metadata(original_transaction_version: int, reason: diem_types.RefundReason) -&gt; bytes:
    &#34;&#34;&#34;Create refund metadata for peer to peer transaction script

    Use this function to create metadata when refunding a transaction, pass in the transaction version and
    a reason.

    List of reason types available:

    0. RefundReason__OtherReason
    1. RefundReason__InvalidSubaddress,
    2. RefundReason__UserInitiatedPartialRefund,
    3. RefundReason__UserInitiatedFullRefund,

    Example:

    ```
    &gt;&gt;&gt; from diem import diem_types, txnmetadata
    &gt;&gt;&gt; txnmetadata.refund_metadata(txn_version, diem_types.RefundReason__UserInitiatedFullRefund())

    &#34;&#34;&#34;

    metadata = diem_types.Metadata__RefundMetadata(
        value=diem_types.RefundMetadata__RefundMetadataV0(
            value=diem_types.RefundMetadataV0(  # pyre-ignore
                transaction_version=original_transaction_version, reason=reason
            )
        )
    )
    return metadata.bcs_serialize()</code></pre>
</details>
</dd>
<dt id="diem.txnmetadata.refund_metadata_from_event"><code class="name flex">
<span>def <span class="ident">refund_metadata_from_event</span></span>(<span>event: jsonrpc_pb2.Event) ‑> Optional[bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>create refund metadat for the event</p>
<p>The given event should be the reference event for the refund, it should have metadata describes
the payment details.
May call <code><a title="diem.txnmetadata.find_refund_reference_event" href="#diem.txnmetadata.find_refund_reference_event">find_refund_reference_event()</a></code> function to find reference event from a peer to peer transfer
transaction.</p>
<p>Returns empty bytes array if given event metadata is None or empty string, this is for the case
the peer to peer transaction is a non-custodial to non-custodial account, which does not require
metadata, hence the refund transaction should not have metadata too.</p>
<p>Raises InvalidEventMetadataForRefundError if metadata can't be decoded as
diem_types.GeneralMetadata__GeneralMetadataVersion0 for creating the refund metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refund_metadata_from_event(event: jsonrpc.Event) -&gt; typing.Optional[bytes]:
    &#34;&#34;&#34;create refund metadat for the event

    The given event should be the reference event for the refund, it should have metadata describes
    the payment details.
    May call `find_refund_reference_event` function to find reference event from a peer to peer transfer
    transaction.

    Returns empty bytes array if given event metadata is None or empty string, this is for the case
    the peer to peer transaction is a non-custodial to non-custodial account, which does not require
    metadata, hence the refund transaction should not have metadata too.

    Raises InvalidEventMetadataForRefundError if metadata can&#39;t be decoded as
    diem_types.GeneralMetadata__GeneralMetadataVersion0 for creating the refund metadata
    &#34;&#34;&#34;

    warnings.warn(
        &#34;`refund_metadata_from_event` is deprecated, prefer `refund_metadata` to create `diem_types.Metadata__RefundMetadata` BCS serialized bytes&#34;
    )

    if not event.data.metadata:
        return b&#34;&#34;

    try:
        metadata_bytes = bytes.fromhex(event.data.metadata)
        metadata = diem_types.Metadata.bcs_deserialize(metadata_bytes)

        if isinstance(metadata, diem_types.Metadata__GeneralMetadata):
            if isinstance(metadata.value, diem_types.GeneralMetadata__GeneralMetadataVersion0):
                gmv0 = metadata.value.value
                return general_metadata(gmv0.to_subaddress, gmv0.from_subaddress, event.sequence_number)

            raise InvalidEventMetadataForRefundError(&#34;unknown metadata type: {metadata}&#34;)

        raise InvalidEventMetadataForRefundError(f&#34;unknown metadata type: {metadata}&#34;)
    except ValueError as e:
        raise InvalidEventMetadataForRefundError(f&#34;invalid event metadata for refund: {e}, event: {event}&#34;)</code></pre>
</details>
</dd>
<dt id="diem.txnmetadata.travel_rule"><code class="name flex">
<span>def <span class="ident">travel_rule</span></span>(<span>off_chain_reference_id: str, sender_address: <a title="diem.diem_types.AccountAddress" href="diem_types/index.html#diem.diem_types.AccountAddress">AccountAddress</a>, amount: int) ‑> Tuple[bytes, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Create travel rule metadata bytes and signature message bytes.</p>
<p>This is used for peer to peer transfer between 2 custodial accounts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def travel_rule(
    off_chain_reference_id: str, sender_address: diem_types.AccountAddress, amount: int
) -&gt; typing.Tuple[bytes, bytes]:
    &#34;&#34;&#34;Create travel rule metadata bytes and signature message bytes.

    This is used for peer to peer transfer between 2 custodial accounts.
    &#34;&#34;&#34;

    metadata = diem_types.Metadata__TravelRuleMetadata(
        value=diem_types.TravelRuleMetadata__TravelRuleMetadataVersion0(
            value=diem_types.TravelRuleMetadataV0(off_chain_reference_id=off_chain_reference_id)
        )
    )

    # receiver_bcs_data = bcs(metadata, sender_address, amount) + &#34;@@$$DIEM_ATTEST$$@@&#34; /*ASCII-encoded string*/
    attest = Attest(metadata=metadata, sender_address=sender_address, amount=serde_types.uint64(amount))  # pyre-ignore
    signing_msg = attest.bcs_serialize() + b&#34;@@$$DIEM_ATTEST$$@@&#34;

    return (metadata.bcs_serialize(), signing_msg)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="diem.txnmetadata.Attest"><code class="flex name class">
<span>class <span class="ident">Attest</span></span>
<span>(</span><span>metadata: <a title="diem.diem_types.Metadata" href="diem_types/index.html#diem.diem_types.Metadata">Metadata</a>, sender_address: <a title="diem.diem_types.AccountAddress" href="diem_types/index.html#diem.diem_types.AccountAddress">AccountAddress</a>, amount: numpy.uint64)</span>
</code></dt>
<dd>
<div class="desc"><p>Attest(metadata: diem.diem_types.Metadata, sender_address: diem.diem_types.AccountAddress, amount: numpy.uint64)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Attest:

    metadata: diem_types.Metadata
    sender_address: diem_types.AccountAddress
    amount: serde_types.uint64  # pyre-ignore

    def bcs_serialize(self) -&gt; bytes:
        return bcs.serialize(self, Attest)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="diem.txnmetadata.Attest.amount"><code class="name">var <span class="ident">amount</span> : numpy.uint64</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.txnmetadata.Attest.metadata"><code class="name">var <span class="ident">metadata</span> : <a title="diem.diem_types.Metadata" href="diem_types/index.html#diem.diem_types.Metadata">Metadata</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="diem.txnmetadata.Attest.sender_address"><code class="name">var <span class="ident">sender_address</span> : <a title="diem.diem_types.AccountAddress" href="diem_types/index.html#diem.diem_types.AccountAddress">AccountAddress</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="diem.txnmetadata.Attest.bcs_serialize"><code class="name flex">
<span>def <span class="ident">bcs_serialize</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bcs_serialize(self) -&gt; bytes:
    return bcs.serialize(self, Attest)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="diem.txnmetadata.InvalidEventMetadataForRefundError"><code class="flex name class">
<span>class <span class="ident">InvalidEventMetadataForRefundError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidEventMetadataForRefundError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="diem" href="index.html">diem</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="diem.txnmetadata.coin_trade_metadata" href="#diem.txnmetadata.coin_trade_metadata">coin_trade_metadata</a></code></li>
<li><code><a title="diem.txnmetadata.decode_structure" href="#diem.txnmetadata.decode_structure">decode_structure</a></code></li>
<li><code><a title="diem.txnmetadata.find_refund_reference_event" href="#diem.txnmetadata.find_refund_reference_event">find_refund_reference_event</a></code></li>
<li><code><a title="diem.txnmetadata.general_metadata" href="#diem.txnmetadata.general_metadata">general_metadata</a></code></li>
<li><code><a title="diem.txnmetadata.refund_metadata" href="#diem.txnmetadata.refund_metadata">refund_metadata</a></code></li>
<li><code><a title="diem.txnmetadata.refund_metadata_from_event" href="#diem.txnmetadata.refund_metadata_from_event">refund_metadata_from_event</a></code></li>
<li><code><a title="diem.txnmetadata.travel_rule" href="#diem.txnmetadata.travel_rule">travel_rule</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="diem.txnmetadata.Attest" href="#diem.txnmetadata.Attest">Attest</a></code></h4>
<ul class="">
<li><code><a title="diem.txnmetadata.Attest.amount" href="#diem.txnmetadata.Attest.amount">amount</a></code></li>
<li><code><a title="diem.txnmetadata.Attest.bcs_serialize" href="#diem.txnmetadata.Attest.bcs_serialize">bcs_serialize</a></code></li>
<li><code><a title="diem.txnmetadata.Attest.metadata" href="#diem.txnmetadata.Attest.metadata">metadata</a></code></li>
<li><code><a title="diem.txnmetadata.Attest.sender_address" href="#diem.txnmetadata.Attest.sender_address">sender_address</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="diem.txnmetadata.InvalidEventMetadataForRefundError" href="#diem.txnmetadata.InvalidEventMetadataForRefundError">InvalidEventMetadataForRefundError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>