import typing
from pylibra import serde_types as st
from pylibra.libra_types import (
    Script,
    TypeTag,
    AccountAddress,
    TransactionArgument__Bool,
    TransactionArgument__U8,
    TransactionArgument__U64,
    TransactionArgument__U128,
    TransactionArgument__Address,
    TransactionArgument__U8Vector,
)


def encode_add_currency_to_account_script(currency: TypeTag) -> Script:
    """Add a `Currency` balance to `account`, which will enable `account` to send and receive `Libra<Currency>`.

    Aborts with NOT_A_CURRENCY if `Currency` is not an accepted currency type in the Libra
    system Aborts with `LibraAccount::ADD_EXISTING_CURRENCY` if the account already holds
    a balance in `Currency`. Aborts with `LibraAccount::PARENT_VASP_CURRENCY_LIMITS_DNE`
    if `account` is a `ChildVASP` whose parent does not have an `AccountLimits<Currency>`
    resource.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x02\x03\x02\x06\x04\x08\x02\x05\x0a\x07\x07\x11\x1a\x08\x2b\x10\x00\x00\x00\x01\x00\x01\x01\x01\x00\x02\x01\x06\x0c\x00\x01\x09\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x0c\x61\x64\x64\x5f\x63\x75\x72\x72\x65\x6e\x63\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x00\x01\x03\x0b\x00\x38\x00\x02",
        ty_args=[currency],
        args=[],
    )


def encode_add_recovery_rotation_capability_script(recovery_address: AccountAddress) -> Script:
    """Add the `KeyRotationCapability` for `to_recover_account` to the `RecoveryAddress` resource under `recovery_address`.

    ## Aborts * Aborts with `LibraAccount::EKEY_ROTATION_CAPABILITY_ALREADY_EXTRACTED` if
    `account` has already delegated its `KeyRotationCapability`. * Aborts with
    `RecoveryAddress:ENOT_A_RECOVERY_ADDRESS` if `recovery_address` does not have a
    `RecoveryAddress` resource. * Aborts with
    `RecoveryAddress::EINVALID_KEY_ROTATION_DELEGATION` if `to_recover_account` and
    `recovery_address` do not belong to the same VASP.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x04\x02\x04\x04\x03\x08\x0a\x05\x12\x0f\x07\x21\x6b\x08\x8c\x01\x10\x00\x00\x00\x01\x00\x02\x01\x00\x00\x03\x00\x01\x00\x01\x04\x02\x03\x00\x01\x06\x0c\x01\x08\x00\x02\x08\x00\x05\x00\x02\x06\x0c\x05\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x0f\x52\x65\x63\x6f\x76\x65\x72\x79\x41\x64\x64\x72\x65\x73\x73\x15\x4b\x65\x79\x52\x6f\x74\x61\x74\x69\x6f\x6e\x43\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1f\x65\x78\x74\x72\x61\x63\x74\x5f\x6b\x65\x79\x5f\x72\x6f\x74\x61\x74\x69\x6f\x6e\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x17\x61\x64\x64\x5f\x72\x6f\x74\x61\x74\x69\x6f\x6e\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x04\x03\x05\x0b\x00\x11\x00\x0a\x01\x11\x01\x02",
        ty_args=[],
        args=[TransactionArgument__Address(recovery_address)],
    )


def encode_add_validator_script(validator_address: AccountAddress) -> Script:
    """Add `new_validator` to the validator set.

    Fails if the `new_validator` address is already in the validator set or does not have
    a `ValidatorConfig` resource stored at the address. Emits a NewEpochEvent.
    TODO(valerini): rename to add_validator_and_reconfigure?
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x05\x07\x0c\x1a\x08\x26\x10\x00\x00\x00\x01\x00\x01\x00\x02\x06\x0c\x05\x00\x0b\x4c\x69\x62\x72\x61\x53\x79\x73\x74\x65\x6d\x0d\x61\x64\x64\x5f\x76\x61\x6c\x69\x64\x61\x74\x6f\x72\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x04\x0b\x00\x0a\x01\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__Address(validator_address)],
    )


def encode_burn_script(token: TypeTag, sliding_nonce: st.uint64, preburn_address: AccountAddress) -> Script:
    """Permanently destroy the `Token`s stored in the oldest burn request under the `Preburn` resource.

    This will only succeed if `account` has a `MintCapability<Token>`, a `Preburn<Token>`
    resource exists under `preburn_address`, and there is a pending burn request.
    sliding_nonce is a unique nonce for operation, see sliding_nonce.move for details
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x04\x03\x04\x0b\x04\x0f\x02\x05\x11\x11\x07\x22\x2e\x08\x50\x10\x00\x00\x00\x01\x01\x02\x00\x01\x00\x00\x03\x02\x01\x01\x01\x01\x04\x02\x06\x0c\x03\x00\x02\x06\x0c\x05\x03\x06\x0c\x03\x05\x01\x09\x00\x05\x4c\x69\x62\x72\x61\x0c\x53\x6c\x69\x64\x69\x6e\x67\x4e\x6f\x6e\x63\x65\x15\x72\x65\x63\x6f\x72\x64\x5f\x6e\x6f\x6e\x63\x65\x5f\x6f\x72\x5f\x61\x62\x6f\x72\x74\x04\x62\x75\x72\x6e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x03\x01\x07\x0a\x00\x0a\x01\x11\x00\x0b\x00\x0a\x02\x38\x00\x02",
        ty_args=[token],
        args=[TransactionArgument__U64(sliding_nonce), TransactionArgument__Address(preburn_address)],
    )


def encode_burn_txn_fees_script(coin_type: TypeTag) -> Script:
    """Burn transaction fees that have been collected in the given `currency` and relinquish to the association.

    The currency must be non-synthetic.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x02\x03\x02\x06\x04\x08\x02\x05\x0a\x07\x07\x11\x19\x08\x2a\x10\x00\x00\x00\x01\x00\x01\x01\x01\x00\x02\x01\x06\x0c\x00\x01\x09\x00\x0e\x54\x72\x61\x6e\x73\x61\x63\x74\x69\x6f\x6e\x46\x65\x65\x09\x62\x75\x72\x6e\x5f\x66\x65\x65\x73\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x00\x01\x03\x0b\x00\x38\x00\x02",
        ty_args=[coin_type],
        args=[],
    )


def encode_cancel_burn_script(token: TypeTag, preburn_address: AccountAddress) -> Script:
    """Cancel the oldest burn request from `preburn_address` and return the funds.

    Fails if the sender does not have a published `BurnCapability<Token>`.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x02\x03\x02\x06\x04\x08\x02\x05\x0a\x08\x07\x12\x19\x08\x2b\x10\x00\x00\x00\x01\x00\x01\x01\x01\x00\x02\x02\x06\x0c\x05\x00\x01\x09\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x0b\x63\x61\x6e\x63\x65\x6c\x5f\x62\x75\x72\x6e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x00\x01\x04\x0b\x00\x0a\x01\x38\x00\x02",
        ty_args=[token],
        args=[TransactionArgument__Address(preburn_address)],
    )


def encode_create_child_vasp_account_script(
    coin_type: TypeTag,
    child_address: AccountAddress,
    auth_key_prefix: bytes,
    add_all_currencies: st.bool,
    child_initial_balance: st.uint64,
) -> Script:
    """Create a `ChildVASP` account for sender `parent_vasp` at `child_address` with a balance of `child_initial_balance` in `CoinType` and an initial authentication_key `auth_key_prefix | child_address`.

    If `add_all_currencies` is true, the child address will have a zero balance in all
    available currencies in the system. This account will a child of the transaction
    sender, which must be a ParentVASP. ## Aborts The transaction will abort: * If
    `parent_vasp` is not a parent vasp with error: `Roles::EINVALID_PARENT_ROLE` * If
    `child_address` already exists with error: `Roles::EROLE_ALREADY_ASSIGNED` * If
    `parent_vasp` already has 256 child accounts with error: `VASP::ETOO_MANY_CHILDREN` *
    If `parent_vasp` does not hold limits for `CoinType` with error:
    `VASP::ENOT_A_PARENT_VASP` * If `CoinType` is not a registered currency with error:
    `LibraAccount::ENOT_A_CURRENCY` * If `parent_vasp`'s withdrawal capability has been
    extracted with error: `LibraAccount::EWITHDRAWAL_CAPABILITY_ALREADY_EXTRACTED` * If
    `parent_vasp` doesn't hold `CoinType` and `child_initial_balance > 0` with error:
    `LibraAccount::EPAYER_DOESNT_HOLD_CURRENCY` * If `parent_vasp` doesn't at least
    `child_initial_balance` of `CoinType` in its account balance with error:
    `LibraAccount::EINSUFFICIENT_BALANCE`
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x08\x01\x00\x02\x02\x02\x04\x03\x06\x16\x04\x1c\x04\x05\x20\x23\x07\x43\x7b\x08\xbe\x01\x10\x06\xce\x01\x04\x00\x00\x00\x01\x01\x00\x00\x02\x00\x01\x01\x01\x00\x03\x02\x03\x00\x00\x04\x04\x01\x01\x01\x00\x05\x03\x01\x00\x00\x06\x02\x06\x04\x06\x0c\x05\x0a\x02\x01\x00\x01\x06\x0c\x01\x08\x00\x05\x06\x08\x00\x05\x03\x0a\x02\x0a\x02\x05\x06\x0c\x05\x0a\x02\x01\x03\x01\x09\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x12\x57\x69\x74\x68\x64\x72\x61\x77\x43\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x19\x63\x72\x65\x61\x74\x65\x5f\x63\x68\x69\x6c\x64\x5f\x76\x61\x73\x70\x5f\x61\x63\x63\x6f\x75\x6e\x74\x1b\x65\x78\x74\x72\x61\x63\x74\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x08\x70\x61\x79\x5f\x66\x72\x6f\x6d\x1b\x72\x65\x73\x74\x6f\x72\x65\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x0a\x02\x01\x00\x01\x01\x05\x03\x19\x0a\x00\x0a\x01\x0b\x02\x0a\x03\x38\x00\x0a\x04\x06\x00\x00\x00\x00\x00\x00\x00\x00\x24\x03\x0a\x05\x16\x0b\x00\x11\x01\x0c\x05\x0e\x05\x0a\x01\x0a\x04\x07\x00\x07\x00\x38\x01\x0b\x05\x11\x03\x05\x18\x0b\x00\x01\x02",
        ty_args=[coin_type],
        args=[
            TransactionArgument__Address(child_address),
            TransactionArgument__U8Vector(auth_key_prefix),
            TransactionArgument__Bool(add_all_currencies),
            TransactionArgument__U64(child_initial_balance),
        ],
    )


def encode_create_designated_dealer_script(
    currency: TypeTag,
    sliding_nonce: st.uint64,
    addr: AccountAddress,
    auth_key_prefix: bytes,
    human_name: bytes,
    base_url: bytes,
    compliance_public_key: bytes,
    add_all_currencies: st.bool,
) -> Script:
    """Create an account with the DesignatedDealer role at `addr` with authentication key `auth_key_prefix` | `addr` and a 0 balance of type `Currency`.

    If `add_all_currencies` is true, 0 balances for all available currencies in the system
    will also be added. This can only be invoked by an account with the TreasuryCompliance
    role.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x04\x03\x04\x0b\x04\x0f\x02\x05\x11\x23\x07\x34\x49\x08\x7d\x10\x00\x00\x00\x01\x01\x02\x00\x01\x00\x00\x03\x02\x01\x01\x01\x01\x04\x02\x06\x0c\x03\x00\x07\x06\x0c\x05\x0a\x02\x0a\x02\x0a\x02\x0a\x02\x01\x08\x06\x0c\x03\x05\x0a\x02\x0a\x02\x0a\x02\x0a\x02\x01\x01\x09\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x0c\x53\x6c\x69\x64\x69\x6e\x67\x4e\x6f\x6e\x63\x65\x15\x72\x65\x63\x6f\x72\x64\x5f\x6e\x6f\x6e\x63\x65\x5f\x6f\x72\x5f\x61\x62\x6f\x72\x74\x18\x63\x72\x65\x61\x74\x65\x5f\x64\x65\x73\x69\x67\x6e\x61\x74\x65\x64\x5f\x64\x65\x61\x6c\x65\x72\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x03\x01\x0c\x0a\x00\x0a\x01\x11\x00\x0b\x00\x0a\x02\x0b\x03\x0b\x04\x0b\x05\x0b\x06\x0a\x07\x38\x00\x02",
        ty_args=[currency],
        args=[
            TransactionArgument__U64(sliding_nonce),
            TransactionArgument__Address(addr),
            TransactionArgument__U8Vector(auth_key_prefix),
            TransactionArgument__U8Vector(human_name),
            TransactionArgument__U8Vector(base_url),
            TransactionArgument__U8Vector(compliance_public_key),
            TransactionArgument__Bool(add_all_currencies),
        ],
    )


def encode_create_parent_vasp_account_script(
    coin_type: TypeTag,
    new_account_address: AccountAddress,
    auth_key_prefix: bytes,
    human_name: bytes,
    base_url: bytes,
    compliance_public_key: bytes,
    add_all_currencies: st.bool,
) -> Script:
    """Create an account with the ParentVASP role at `address` with authentication key `auth_key_prefix` | `new_account_address` and a 0 balance of type `currency`.

    If `add_all_currencies` is true, 0 balances for all available currencies in the system
    will also be added. This can only be invoked by an Association account.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x02\x03\x02\x06\x04\x08\x02\x05\x0a\x11\x07\x1b\x28\x08\x43\x10\x00\x00\x00\x01\x00\x01\x01\x01\x00\x02\x07\x06\x0c\x05\x0a\x02\x0a\x02\x0a\x02\x0a\x02\x01\x00\x01\x09\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x1a\x63\x72\x65\x61\x74\x65\x5f\x70\x61\x72\x65\x6e\x74\x5f\x76\x61\x73\x70\x5f\x61\x63\x63\x6f\x75\x6e\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x00\x01\x09\x0b\x00\x0a\x01\x0b\x02\x0b\x03\x0b\x04\x0b\x05\x0a\x06\x38\x00\x02",
        ty_args=[coin_type],
        args=[
            TransactionArgument__Address(new_account_address),
            TransactionArgument__U8Vector(auth_key_prefix),
            TransactionArgument__U8Vector(human_name),
            TransactionArgument__U8Vector(base_url),
            TransactionArgument__U8Vector(compliance_public_key),
            TransactionArgument__Bool(add_all_currencies),
        ],
    )


def encode_create_recovery_address_script() -> Script:
    """Extract the `KeyRotationCapability` for `recovery_account` and publish it in a `RecoveryAddress` resource under `account`.

    ## Aborts * Aborts with `LibraAccount::EKEY_ROTATION_CAPABILITY_ALREADY_EXTRACTED` if
    `account` has already delegated its `KeyRotationCapability`. * Aborts with
    `RecoveryAddress::ENOT_A_VASP` if `account` is not a ParentVASP or ChildVASP
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x04\x02\x04\x04\x03\x08\x0a\x05\x12\x0c\x07\x1e\x5b\x08\x79\x10\x00\x00\x00\x01\x00\x02\x01\x00\x00\x03\x00\x01\x00\x01\x04\x02\x03\x00\x01\x06\x0c\x01\x08\x00\x02\x06\x0c\x08\x00\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x0f\x52\x65\x63\x6f\x76\x65\x72\x79\x41\x64\x64\x72\x65\x73\x73\x15\x4b\x65\x79\x52\x6f\x74\x61\x74\x69\x6f\x6e\x43\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1f\x65\x78\x74\x72\x61\x63\x74\x5f\x6b\x65\x79\x5f\x72\x6f\x74\x61\x74\x69\x6f\x6e\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x07\x70\x75\x62\x6c\x69\x73\x68\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x03\x05\x0a\x00\x0b\x00\x11\x00\x11\x01\x02",
        ty_args=[],
        args=[],
    )


def encode_create_testing_account_script(
    coin_type: TypeTag, new_account_address: AccountAddress, auth_key_prefix: bytes, add_all_currencies: st.bool
) -> Script:
    """Create an account with the ParentVASP role at `address` with authentication key `auth_key_prefix` | `new_account_address` and a 0 balance of type `currency`.

    If `add_all_currencies` is true, 0 balances for all available currencies in the system
    will also be added. This can only be invoked by an Association account. The
    `human_name`, `base_url`, and compliance_public_key` fields of the ParentVASP are
    filled in with dummy information.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x07\x01\x00\x02\x03\x02\x06\x04\x08\x02\x05\x0a\x18\x07\x22\x28\x08\x4a\x10\x06\x5a\x44\x00\x00\x00\x01\x00\x01\x01\x01\x00\x03\x07\x06\x0c\x05\x0a\x02\x0a\x02\x0a\x02\x0a\x02\x01\x00\x04\x06\x0c\x05\x0a\x02\x01\x01\x09\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x1a\x63\x72\x65\x61\x74\x65\x5f\x70\x61\x72\x65\x6e\x74\x5f\x76\x61\x73\x70\x5f\x61\x63\x63\x6f\x75\x6e\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x0a\x02\x08\x07\x74\x65\x73\x74\x6e\x65\x74\x0a\x02\x12\x11\x68\x74\x74\x70\x73\x3a\x2f\x2f\x6c\x69\x62\x72\x61\x2e\x6f\x72\x67\x0a\x02\x21\x20\xb7\xa3\xc1\x2d\xc0\xc8\xc7\x48\xab\x07\x52\x5b\x70\x11\x22\xb8\x8b\xd7\x8f\x60\x0c\x76\x34\x2d\x27\xf2\x5e\x5f\x92\x44\x4c\xde\x01\x01\x02\x01\x09\x0b\x00\x0a\x01\x0b\x02\x07\x00\x07\x01\x07\x02\x0a\x03\x38\x00\x02",
        ty_args=[coin_type],
        args=[
            TransactionArgument__Address(new_account_address),
            TransactionArgument__U8Vector(auth_key_prefix),
            TransactionArgument__Bool(add_all_currencies),
        ],
    )


def encode_create_validator_account_script(new_account_address: AccountAddress, auth_key_prefix: bytes) -> Script:
    """Create a validator account at `new_validator_address` with `auth_key_prefix`."""
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x07\x07\x0e\x26\x08\x34\x10\x00\x00\x00\x01\x00\x01\x00\x03\x06\x0c\x05\x0a\x02\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x18\x63\x72\x65\x61\x74\x65\x5f\x76\x61\x6c\x69\x64\x61\x74\x6f\x72\x5f\x61\x63\x63\x6f\x75\x6e\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x05\x0b\x00\x0a\x01\x0b\x02\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__Address(new_account_address), TransactionArgument__U8Vector(auth_key_prefix)],
    )


def encode_create_validator_operator_account_script(
    new_account_address: AccountAddress, auth_key_prefix: bytes
) -> Script:
    """Create a validator operator account at `new_validator_address` with `auth_key_prefix`."""
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x07\x07\x0e\x2f\x08\x3d\x10\x00\x00\x00\x01\x00\x01\x00\x03\x06\x0c\x05\x0a\x02\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x21\x63\x72\x65\x61\x74\x65\x5f\x76\x61\x6c\x69\x64\x61\x74\x6f\x72\x5f\x6f\x70\x65\x72\x61\x74\x6f\x72\x5f\x61\x63\x63\x6f\x75\x6e\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x05\x0b\x00\x0a\x01\x0b\x02\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__Address(new_account_address), TransactionArgument__U8Vector(auth_key_prefix)],
    )


def encode_freeze_account_script(sliding_nonce: st.uint64, to_freeze_account: AccountAddress) -> Script:
    """Freeze account `address`.

    Initiator must be authorized. `sliding_nonce` is a unique nonce for operation, see
    sliding_nonce.move for details.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x04\x03\x04\x0a\x05\x0e\x0e\x07\x1c\x42\x08\x5e\x10\x00\x00\x00\x01\x00\x02\x00\x01\x00\x01\x03\x02\x01\x00\x02\x06\x0c\x05\x00\x02\x06\x0c\x03\x03\x06\x0c\x03\x05\x0f\x41\x63\x63\x6f\x75\x6e\x74\x46\x72\x65\x65\x7a\x69\x6e\x67\x0c\x53\x6c\x69\x64\x69\x6e\x67\x4e\x6f\x6e\x63\x65\x0e\x66\x72\x65\x65\x7a\x65\x5f\x61\x63\x63\x6f\x75\x6e\x74\x15\x72\x65\x63\x6f\x72\x64\x5f\x6e\x6f\x6e\x63\x65\x5f\x6f\x72\x5f\x61\x62\x6f\x72\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x03\x01\x07\x0a\x00\x0a\x01\x11\x01\x0b\x00\x0a\x02\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__U64(sliding_nonce), TransactionArgument__Address(to_freeze_account)],
    )


def encode_mint_lbr_script(amount_lbr: st.uint64) -> Script:
    """Mint `amount_lbr` LBR from the sending account's constituent coins and deposits the resulting LBR into the sending account."""
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x02\x02\x02\x04\x03\x06\x0f\x05\x15\x10\x07\x25\x63\x08\x88\x01\x10\x00\x00\x00\x01\x01\x00\x00\x02\x00\x01\x00\x00\x03\x01\x02\x00\x00\x04\x03\x02\x00\x01\x06\x0c\x01\x08\x00\x00\x02\x06\x08\x00\x03\x02\x06\x0c\x03\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x12\x57\x69\x74\x68\x64\x72\x61\x77\x43\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1b\x65\x78\x74\x72\x61\x63\x74\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1b\x72\x65\x73\x74\x6f\x72\x65\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x0a\x73\x74\x61\x70\x6c\x65\x5f\x6c\x62\x72\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x04\x01\x09\x0b\x00\x11\x00\x0c\x02\x0e\x02\x0a\x01\x11\x02\x0b\x02\x11\x01\x02",
        ty_args=[],
        args=[TransactionArgument__U64(amount_lbr)],
    )


def encode_modify_publishing_option_script(args: bytes) -> Script:
    """Modify publishing options.

    Takes the LCS bytes of a `VMPublishingOption` object as input.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x06\x07\x0d\x24\x08\x31\x10\x00\x00\x00\x01\x00\x01\x00\x02\x06\x0c\x0a\x02\x00\x0d\x4c\x69\x62\x72\x61\x56\x4d\x43\x6f\x6e\x66\x69\x67\x15\x73\x65\x74\x5f\x70\x75\x62\x6c\x69\x73\x68\x69\x6e\x67\x5f\x6f\x70\x74\x69\x6f\x6e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x04\x0b\x00\x0b\x01\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__U8Vector(args)],
    )


def encode_peer_to_peer_with_metadata_script(
    currency: TypeTag, payee: AccountAddress, amount: st.uint64, metadata: bytes, metadata_signature: bytes
) -> Script:
    """Transfer `amount` coins of type `Currency` from `payer` to `payee` with (optional) associated `metadata` and an (optional) `metadata_signature` on the message `metadata` | `Signer::address_of(payer)` | `amount` | `DualAttestation::DOMAIN_SEPARATOR`.

    The `metadata` and `metadata_signature` parameters are only required if `amount` >=
    `DualAttestation::get_cur_microlibra_limit` LBR and `payer` and `payee` are distinct
    entities (e.g., different VASPs, or a VASP and a DesignatedDealer). Standardized
    `metadata` LCS format can be found in `libra_types::transaction::metadata::Metadata`.
    ## Events When this script executes without aborting, it emits two events:
    `SentPaymentEvent { amount, currency_code = Currency, payee, metadata }` on `payer`'s
    `LibraAccount::sent_events` handle, and `ReceivedPaymentEvent { amount, currency_code
    = Currency, payer, metadata }` on `payee`'s `LibraAccount::received_events` handle. ##
    Common Aborts These aborts can in occur in any payment. * Aborts with
    `LibraAccount::EINSUFFICIENT_BALANCE` if `amount` is greater than `payer`'s balance in
    `Currency`. * Aborts with `LibraAccount::ECOIN_DEPOSIT_IS_ZERO` if `amount` is zero. *
    Aborts with `LibraAccount::EPAYEE_DOES_NOT_EXIST` if no account exists at the address
    `payee`. * Aborts with `LibraAccount::EPAYEE_CANT_ACCEPT_CURRENCY_TYPE` if an account
    exists at `payee`, but it does not accept payments in `Currency`. ## Dual Attestation
    Aborts These aborts can occur in any payment subject to dual attestation. * Aborts
    with `DualAttestation::EMALFORMED_METADATA_SIGNATURE` if `metadata_signature`'s is not
    64 bytes. * Aborts with `DualAttestation:EINVALID_METADATA_SIGNATURE` if
    `metadata_signature` does not verify on the message `metadata` | `payer` | `value` |
    `DOMAIN_SEPARATOR` using the `compliance_public_key` published in the `payee`'s
    `DualAttestation::Credential` resource. ## Other Aborts These aborts should only
    happen when `payer` or `payee` have account limit restrictions or have been frozen by
    Libra administrators. * Aborts with `LibraAccount::EWITHDRAWAL_EXCEEDS_LIMITS` if
    `payer` has exceeded their daily withdrawal limits. * Aborts with
    `LibraAccount::EDEPOSIT_EXCEEDS_LIMITS` if `payee` has exceeded their daily deposit
    limits. * Aborts with `LibraAccount::EACCOUNT_FROZEN` if `payer`'s account is frozen.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x07\x01\x00\x02\x02\x02\x04\x03\x06\x10\x04\x16\x02\x05\x18\x1d\x07\x35\x61\x08\x96\x01\x10\x00\x00\x00\x01\x01\x00\x00\x02\x00\x01\x00\x00\x03\x02\x03\x01\x01\x00\x04\x01\x03\x00\x01\x05\x01\x06\x0c\x01\x08\x00\x05\x06\x08\x00\x05\x03\x0a\x02\x0a\x02\x00\x05\x06\x0c\x05\x03\x0a\x02\x0a\x02\x01\x09\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x12\x57\x69\x74\x68\x64\x72\x61\x77\x43\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1b\x65\x78\x74\x72\x61\x63\x74\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x08\x70\x61\x79\x5f\x66\x72\x6f\x6d\x1b\x72\x65\x73\x74\x6f\x72\x65\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x04\x01\x0c\x0b\x00\x11\x00\x0c\x05\x0e\x05\x0a\x01\x0a\x02\x0b\x03\x0b\x04\x38\x00\x0b\x05\x11\x02\x02",
        ty_args=[currency],
        args=[
            TransactionArgument__Address(payee),
            TransactionArgument__U64(amount),
            TransactionArgument__U8Vector(metadata),
            TransactionArgument__U8Vector(metadata_signature),
        ],
    )


def encode_preburn_script(token: TypeTag, amount: st.uint64) -> Script:
    """Preburn `amount` `Token`s from `account`.

    This will only succeed if `account` already has a published `Preburn<Token>` resource.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x07\x01\x00\x02\x02\x02\x04\x03\x06\x10\x04\x16\x02\x05\x18\x15\x07\x2d\x60\x08\x8d\x01\x10\x00\x00\x00\x01\x01\x00\x00\x02\x00\x01\x00\x00\x03\x02\x03\x01\x01\x00\x04\x01\x03\x00\x01\x05\x01\x06\x0c\x01\x08\x00\x03\x06\x0c\x06\x08\x00\x03\x00\x02\x06\x0c\x03\x01\x09\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x12\x57\x69\x74\x68\x64\x72\x61\x77\x43\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1b\x65\x78\x74\x72\x61\x63\x74\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x07\x70\x72\x65\x62\x75\x72\x6e\x1b\x72\x65\x73\x74\x6f\x72\x65\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x04\x01\x0a\x0a\x00\x11\x00\x0c\x02\x0b\x00\x0e\x02\x0a\x01\x38\x00\x0b\x02\x11\x02\x02",
        ty_args=[token],
        args=[TransactionArgument__U64(amount)],
    )


def encode_publish_account_limit_definition_script(coin_type: TypeTag) -> Script:
    """Publishes an unrestricted `LimitsDefintion<CoinType>` under `account`.

    Will abort if a resource with the same type already exists under `account`. No windows
    will point to this limit at the time it is published.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x02\x03\x02\x06\x04\x08\x02\x05\x0a\x07\x07\x11\x2a\x08\x3b\x10\x00\x00\x00\x01\x00\x01\x01\x01\x00\x02\x01\x06\x0c\x00\x01\x09\x00\x0d\x41\x63\x63\x6f\x75\x6e\x74\x4c\x69\x6d\x69\x74\x73\x1b\x70\x75\x62\x6c\x69\x73\x68\x5f\x75\x6e\x72\x65\x73\x74\x72\x69\x63\x74\x65\x64\x5f\x6c\x69\x6d\x69\x74\x73\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x00\x01\x03\x0b\x00\x38\x00\x02",
        ty_args=[coin_type],
        args=[],
    )


def encode_publish_shared_ed25519_public_key_script(public_key: bytes) -> Script:
    """(1) Rotate the authentication key of the sender to `public_key` (2) Publish a resource containing a 32-byte ed25519 public key and the rotation capability of the sender under the sender's address.

    Aborts if the sender already has a `SharedEd25519PublicKey` resource. Aborts if the
    length of `new_public_key` is not 32.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x06\x07\x0d\x1f\x08\x2c\x10\x00\x00\x00\x01\x00\x01\x00\x02\x06\x0c\x0a\x02\x00\x16\x53\x68\x61\x72\x65\x64\x45\x64\x32\x35\x35\x31\x39\x50\x75\x62\x6c\x69\x63\x4b\x65\x79\x07\x70\x75\x62\x6c\x69\x73\x68\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x04\x0b\x00\x0b\x01\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__U8Vector(public_key)],
    )


def encode_remove_validator_script(validator_address: AccountAddress) -> Script:
    """Removes a validator from the validator set.

    Fails if the validator_address is not in the validator set. Emits a NewEpochEvent.
    TODO(valerini): rename to remove_validator_and_reconfigure?
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x05\x07\x0c\x1d\x08\x29\x10\x00\x00\x00\x01\x00\x01\x00\x02\x06\x0c\x05\x00\x0b\x4c\x69\x62\x72\x61\x53\x79\x73\x74\x65\x6d\x10\x72\x65\x6d\x6f\x76\x65\x5f\x76\x61\x6c\x69\x64\x61\x74\x6f\x72\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x04\x0b\x00\x0a\x01\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__Address(validator_address)],
    )


def encode_rotate_authentication_key_script(new_key: bytes) -> Script:
    """Rotate the sender's authentication key to `new_key`.

    `new_key` should be a 256 bit sha3 hash of an ed25519 public key. * Aborts with
    `LibraAccount::EKEY_ROTATION_CAPABILITY_ALREADY_EXTRACTED` if the
    `KeyRotationCapability` for `account` has already been extracted. * Aborts with `0` if
    the key rotation capability held by the account doesn't match the sender's address. *
    Aborts with `LibraAccount::EMALFORMED_AUTHENTICATION_KEY` if the length of `new_key`
    != 32.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x04\x02\x04\x04\x03\x08\x19\x05\x21\x20\x07\x41\xaf\x01\x08\xf0\x01\x10\x00\x00\x00\x01\x00\x03\x01\x00\x01\x02\x00\x01\x00\x00\x04\x00\x02\x00\x00\x05\x03\x04\x00\x00\x06\x02\x05\x00\x00\x07\x06\x05\x00\x01\x06\x0c\x01\x05\x01\x08\x00\x01\x06\x08\x00\x01\x06\x05\x00\x02\x06\x08\x00\x0a\x02\x02\x06\x0c\x0a\x02\x03\x08\x00\x01\x03\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x06\x53\x69\x67\x6e\x65\x72\x0a\x61\x64\x64\x72\x65\x73\x73\x5f\x6f\x66\x15\x4b\x65\x79\x52\x6f\x74\x61\x74\x69\x6f\x6e\x43\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1f\x65\x78\x74\x72\x61\x63\x74\x5f\x6b\x65\x79\x5f\x72\x6f\x74\x61\x74\x69\x6f\x6e\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1f\x6b\x65\x79\x5f\x72\x6f\x74\x61\x74\x69\x6f\x6e\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x5f\x61\x64\x64\x72\x65\x73\x73\x1f\x72\x65\x73\x74\x6f\x72\x65\x5f\x6b\x65\x79\x5f\x72\x6f\x74\x61\x74\x69\x6f\x6e\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x19\x72\x6f\x74\x61\x74\x65\x5f\x61\x75\x74\x68\x65\x6e\x74\x69\x63\x61\x74\x69\x6f\x6e\x5f\x6b\x65\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x07\x08\x14\x0a\x00\x11\x01\x0c\x02\x0e\x02\x11\x02\x14\x0b\x00\x11\x00\x21\x0c\x03\x0b\x03\x03\x0e\x06\x00\x00\x00\x00\x00\x00\x00\x00\x27\x0e\x02\x0b\x01\x11\x04\x0b\x02\x11\x03\x02",
        ty_args=[],
        args=[TransactionArgument__U8Vector(new_key)],
    )


def encode_rotate_authentication_key_with_nonce_script(sliding_nonce: st.uint64, new_key: bytes) -> Script:
    """Rotate the sender's authentication key to `new_key`.

    `new_key` should be a 256 bit sha3 hash of an ed25519 public key. This script also
    takes `sliding_nonce`, as a unique nonce for this operation. See sliding_nonce.move
    for details.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x04\x02\x04\x04\x03\x08\x14\x05\x1c\x17\x07\x33\xa0\x01\x08\xd3\x01\x10\x00\x00\x00\x01\x00\x03\x01\x00\x01\x02\x00\x01\x00\x00\x04\x02\x03\x00\x00\x05\x03\x01\x00\x00\x06\x04\x01\x00\x02\x06\x0c\x03\x00\x01\x06\x0c\x01\x08\x00\x02\x06\x08\x00\x0a\x02\x03\x06\x0c\x03\x0a\x02\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x0c\x53\x6c\x69\x64\x69\x6e\x67\x4e\x6f\x6e\x63\x65\x15\x72\x65\x63\x6f\x72\x64\x5f\x6e\x6f\x6e\x63\x65\x5f\x6f\x72\x5f\x61\x62\x6f\x72\x74\x15\x4b\x65\x79\x52\x6f\x74\x61\x74\x69\x6f\x6e\x43\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1f\x65\x78\x74\x72\x61\x63\x74\x5f\x6b\x65\x79\x5f\x72\x6f\x74\x61\x74\x69\x6f\x6e\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1f\x72\x65\x73\x74\x6f\x72\x65\x5f\x6b\x65\x79\x5f\x72\x6f\x74\x61\x74\x69\x6f\x6e\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x19\x72\x6f\x74\x61\x74\x65\x5f\x61\x75\x74\x68\x65\x6e\x74\x69\x63\x61\x74\x69\x6f\x6e\x5f\x6b\x65\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x05\x03\x0c\x0a\x00\x0a\x01\x11\x00\x0b\x00\x11\x01\x0c\x03\x0e\x03\x0b\x02\x11\x03\x0b\x03\x11\x02\x02",
        ty_args=[],
        args=[TransactionArgument__U64(sliding_nonce), TransactionArgument__U8Vector(new_key)],
    )


def encode_rotate_authentication_key_with_recovery_address_script(
    recovery_address: AccountAddress, to_recover: AccountAddress, new_key: bytes
) -> Script:
    """Rotate the authentication key of `account` to `new_key` using the `KeyRotationCapability` stored under `recovery_address`.

    ## Aborts * Aborts with `RecoveryAddress::ENOT_A_RECOVERY_ADDRESS` if
    `recovery_address` does not have a `RecoveryAddress` resource * Aborts with
    `RecoveryAddress::ECANNOT_ROTATE_KEY` if `account` is not `recovery_address` or
    `to_recover`. * Aborts with `LibraAccount::EMALFORMED_AUTHENTICATION_KEY` if `new_key`
    is not 32 bytes. * Aborts with `RecoveryAddress::ECANNOT_ROTATE_KEY` if `account` has
    not delegated its `KeyRotationCapability` to `recovery_address`.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x08\x07\x0f\x2a\x08\x39\x10\x00\x00\x00\x01\x00\x01\x00\x04\x06\x0c\x05\x05\x0a\x02\x00\x0f\x52\x65\x63\x6f\x76\x65\x72\x79\x41\x64\x64\x72\x65\x73\x73\x19\x72\x6f\x74\x61\x74\x65\x5f\x61\x75\x74\x68\x65\x6e\x74\x69\x63\x61\x74\x69\x6f\x6e\x5f\x6b\x65\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x06\x0b\x00\x0a\x01\x0a\x02\x0b\x03\x11\x00\x02",
        ty_args=[],
        args=[
            TransactionArgument__Address(recovery_address),
            TransactionArgument__Address(to_recover),
            TransactionArgument__U8Vector(new_key),
        ],
    )


def encode_rotate_dual_attestation_info_script(new_url: bytes, new_key: bytes) -> Script:
    """Rotate `account`'s base URL to `new_url` and its compliance public key to `new_key`.

    Aborts if `account` is not a ParentVASP or DesignatedDealer Aborts if `new_key` is not
    a well-formed public key
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x0a\x05\x0c\x0d\x07\x19\x3d\x08\x56\x10\x00\x00\x00\x01\x00\x01\x00\x00\x02\x00\x01\x00\x02\x06\x0c\x0a\x02\x00\x03\x06\x0c\x0a\x02\x0a\x02\x0f\x44\x75\x61\x6c\x41\x74\x74\x65\x73\x74\x61\x74\x69\x6f\x6e\x0f\x72\x6f\x74\x61\x74\x65\x5f\x62\x61\x73\x65\x5f\x75\x72\x6c\x1c\x72\x6f\x74\x61\x74\x65\x5f\x63\x6f\x6d\x70\x6c\x69\x61\x6e\x63\x65\x5f\x70\x75\x62\x6c\x69\x63\x5f\x6b\x65\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x02\x01\x07\x0a\x00\x0b\x01\x11\x00\x0b\x00\x0b\x02\x11\x01\x02",
        ty_args=[],
        args=[TransactionArgument__U8Vector(new_url), TransactionArgument__U8Vector(new_key)],
    )


def encode_rotate_shared_ed25519_public_key_script(public_key: bytes) -> Script:
    """(1) Rotate the public key stored in `account`'s `SharedEd25519PublicKey` resource to `new_public_key` (2) Rotate the authentication key using the capability stored in `account`'s `SharedEd25519PublicKey` to a new value derived from `new_public_key` Aborts if `account` does not have a `SharedEd25519PublicKey` resource.

    Aborts if the length of `new_public_key` is not 32.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x06\x07\x0d\x22\x08\x2f\x10\x00\x00\x00\x01\x00\x01\x00\x02\x06\x0c\x0a\x02\x00\x16\x53\x68\x61\x72\x65\x64\x45\x64\x32\x35\x35\x31\x39\x50\x75\x62\x6c\x69\x63\x4b\x65\x79\x0a\x72\x6f\x74\x61\x74\x65\x5f\x6b\x65\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x04\x0b\x00\x0b\x01\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__U8Vector(public_key)],
    )


def encode_set_validator_config_script(
    validator_account: AccountAddress,
    consensus_pubkey: bytes,
    validator_network_identity_pubkey: bytes,
    validator_network_address: bytes,
    fullnodes_network_identity_pubkey: bytes,
    fullnodes_network_address: bytes,
) -> Script:
    """Set validator's config locally.

    Does not emit NewEpochEvent, the config is NOT changed in the validator set.
    TODO(valerini): rename to register_validator_config to avoid confusion with
    set_validator_config_and_reconfigure script.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x0f\x07\x16\x1b\x08\x31\x10\x00\x00\x00\x01\x00\x01\x00\x07\x06\x0c\x05\x0a\x02\x0a\x02\x0a\x02\x0a\x02\x0a\x02\x00\x0f\x56\x61\x6c\x69\x64\x61\x74\x6f\x72\x43\x6f\x6e\x66\x69\x67\x0a\x73\x65\x74\x5f\x63\x6f\x6e\x66\x69\x67\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x09\x0b\x00\x0a\x01\x0b\x02\x0b\x03\x0b\x04\x0b\x05\x0b\x06\x11\x00\x02",
        ty_args=[],
        args=[
            TransactionArgument__Address(validator_account),
            TransactionArgument__U8Vector(consensus_pubkey),
            TransactionArgument__U8Vector(validator_network_identity_pubkey),
            TransactionArgument__U8Vector(validator_network_address),
            TransactionArgument__U8Vector(fullnodes_network_identity_pubkey),
            TransactionArgument__U8Vector(fullnodes_network_address),
        ],
    )


def encode_set_validator_config_and_reconfigure_script(
    validator_account: AccountAddress,
    consensus_pubkey: bytes,
    validator_network_identity_pubkey: bytes,
    validator_network_address: bytes,
    fullnodes_network_identity_pubkey: bytes,
    fullnodes_network_address: bytes,
) -> Script:
    """Set validator's config and updates the config in the validator set.

    NewEpochEvent is emitted.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x04\x03\x04\x0a\x05\x0e\x13\x07\x21\x45\x08\x66\x10\x00\x00\x00\x01\x01\x02\x00\x01\x00\x00\x03\x02\x01\x00\x07\x06\x0c\x05\x0a\x02\x0a\x02\x0a\x02\x0a\x02\x0a\x02\x00\x02\x06\x0c\x05\x0b\x4c\x69\x62\x72\x61\x53\x79\x73\x74\x65\x6d\x0f\x56\x61\x6c\x69\x64\x61\x74\x6f\x72\x43\x6f\x6e\x66\x69\x67\x0a\x73\x65\x74\x5f\x63\x6f\x6e\x66\x69\x67\x1d\x75\x70\x64\x61\x74\x65\x5f\x63\x6f\x6e\x66\x69\x67\x5f\x61\x6e\x64\x5f\x72\x65\x63\x6f\x6e\x66\x69\x67\x75\x72\x65\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x0c\x0a\x00\x0a\x01\x0b\x02\x0b\x03\x0b\x04\x0b\x05\x0b\x06\x11\x00\x0b\x00\x0a\x01\x11\x01\x02",
        ty_args=[],
        args=[
            TransactionArgument__Address(validator_account),
            TransactionArgument__U8Vector(consensus_pubkey),
            TransactionArgument__U8Vector(validator_network_identity_pubkey),
            TransactionArgument__U8Vector(validator_network_address),
            TransactionArgument__U8Vector(fullnodes_network_identity_pubkey),
            TransactionArgument__U8Vector(fullnodes_network_address),
        ],
    )


def encode_set_validator_operator_script(operator_account: AccountAddress) -> Script:
    """Set validator's operator."""
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x05\x07\x0c\x1d\x08\x29\x10\x00\x00\x00\x01\x00\x01\x00\x02\x06\x0c\x05\x00\x0f\x56\x61\x6c\x69\x64\x61\x74\x6f\x72\x43\x6f\x6e\x66\x69\x67\x0c\x73\x65\x74\x5f\x6f\x70\x65\x72\x61\x74\x6f\x72\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x04\x0b\x00\x0a\x01\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__Address(operator_account)],
    )


def encode_testnet_mint_script(token: TypeTag, payee: AccountAddress, amount: st.uint64) -> Script:
    """Send `amount` coins of type `Token` to `payee`."""
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x08\x01\x00\x08\x02\x08\x04\x03\x0c\x25\x04\x31\x04\x05\x35\x28\x07\x5d\xc1\x01\x08\x9e\x02\x10\x06\xae\x02\x16\x00\x00\x00\x01\x00\x02\x00\x03\x02\x07\x01\x00\x00\x04\x00\x01\x00\x03\x05\x02\x03\x00\x01\x06\x01\x01\x01\x01\x02\x08\x03\x04\x00\x02\x09\x02\x05\x00\x02\x0a\x06\x00\x01\x01\x02\x0b\x05\x00\x00\x02\x09\x05\x09\x00\x01\x03\x01\x06\x0c\x01\x05\x01\x01\x01\x08\x00\x05\x06\x08\x00\x05\x03\x0a\x02\x0a\x02\x03\x06\x0c\x05\x03\x07\x08\x00\x01\x03\x01\x03\x01\x03\x01\x09\x00\x0f\x44\x75\x61\x6c\x41\x74\x74\x65\x73\x74\x61\x74\x69\x6f\x6e\x05\x4c\x69\x62\x72\x61\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x06\x53\x69\x67\x6e\x65\x72\x18\x67\x65\x74\x5f\x63\x75\x72\x5f\x6d\x69\x63\x72\x6f\x6c\x69\x62\x72\x61\x5f\x6c\x69\x6d\x69\x74\x0a\x61\x64\x64\x72\x65\x73\x73\x5f\x6f\x66\x14\x61\x70\x70\x72\x6f\x78\x5f\x6c\x62\x72\x5f\x66\x6f\x72\x5f\x76\x61\x6c\x75\x65\x12\x57\x69\x74\x68\x64\x72\x61\x77\x43\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x09\x65\x78\x69\x73\x74\x73\x5f\x61\x74\x1b\x65\x78\x74\x72\x61\x63\x74\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x08\x70\x61\x79\x5f\x66\x72\x6f\x6d\x1b\x72\x65\x73\x74\x6f\x72\x65\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x05\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xdd\x0a\x02\x01\x00\x01\x01\x07\x08\x2b\x0a\x01\x11\x03\x0c\x04\x0b\x04\x03\x09\x0b\x00\x01\x06\xcb\x15\x7a\x00\x00\x00\x00\x00\x27\x0a\x00\x11\x01\x07\x00\x21\x0c\x06\x0b\x06\x03\x14\x0b\x00\x01\x06\xcc\x15\x7a\x00\x00\x00\x00\x00\x27\x0a\x02\x38\x00\x11\x00\x23\x0c\x08\x0b\x08\x03\x1f\x0b\x00\x01\x06\xcd\x15\x7a\x00\x00\x00\x00\x00\x27\x0b\x00\x11\x04\x0c\x03\x0e\x03\x0a\x01\x0a\x02\x07\x01\x07\x01\x38\x01\x0b\x03\x11\x06\x02",
        ty_args=[token],
        args=[TransactionArgument__Address(payee), TransactionArgument__U64(amount)],
    )


def encode_tiered_mint_script(
    coin_type: TypeTag,
    sliding_nonce: st.uint64,
    designated_dealer_address: AccountAddress,
    mint_amount: st.uint64,
    tier_index: st.uint64,
) -> Script:
    """Mint 'mint_amount' to 'designated_dealer_address' for 'tier_index' tier.

    Max valid tier index is 3 since there are max 4 tiers per DD. Sender should be
    treasury compliance account and receiver authorized DD. `sliding_nonce` is a unique
    nonce for operation, see sliding_nonce.move for details.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x04\x03\x04\x0b\x04\x0f\x02\x05\x11\x15\x07\x26\x3c\x08\x62\x10\x00\x00\x00\x01\x01\x02\x00\x01\x00\x00\x03\x02\x01\x01\x01\x01\x04\x02\x06\x0c\x03\x00\x04\x06\x0c\x05\x03\x03\x05\x06\x0c\x03\x05\x03\x03\x01\x09\x00\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x0c\x53\x6c\x69\x64\x69\x6e\x67\x4e\x6f\x6e\x63\x65\x15\x72\x65\x63\x6f\x72\x64\x5f\x6e\x6f\x6e\x63\x65\x5f\x6f\x72\x5f\x61\x62\x6f\x72\x74\x0b\x74\x69\x65\x72\x65\x64\x5f\x6d\x69\x6e\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x03\x01\x09\x0a\x00\x0a\x01\x11\x00\x0b\x00\x0a\x02\x0a\x03\x0a\x04\x38\x00\x02",
        ty_args=[coin_type],
        args=[
            TransactionArgument__U64(sliding_nonce),
            TransactionArgument__Address(designated_dealer_address),
            TransactionArgument__U64(mint_amount),
            TransactionArgument__U64(tier_index),
        ],
    )


def encode_unfreeze_account_script(sliding_nonce: st.uint64, to_unfreeze_account: AccountAddress) -> Script:
    """Unfreeze account `address`.

    Initiator must be authorized. `sliding_nonce` is a unique nonce for operation, see
    sliding_nonce.move for details.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x04\x03\x04\x0a\x05\x0e\x0e\x07\x1c\x44\x08\x60\x10\x00\x00\x00\x01\x00\x02\x00\x01\x00\x01\x03\x02\x01\x00\x02\x06\x0c\x05\x00\x02\x06\x0c\x03\x03\x06\x0c\x03\x05\x0f\x41\x63\x63\x6f\x75\x6e\x74\x46\x72\x65\x65\x7a\x69\x6e\x67\x0c\x53\x6c\x69\x64\x69\x6e\x67\x4e\x6f\x6e\x63\x65\x10\x75\x6e\x66\x72\x65\x65\x7a\x65\x5f\x61\x63\x63\x6f\x75\x6e\x74\x15\x72\x65\x63\x6f\x72\x64\x5f\x6e\x6f\x6e\x63\x65\x5f\x6f\x72\x5f\x61\x62\x6f\x72\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x03\x01\x07\x0a\x00\x0a\x01\x11\x01\x0b\x00\x0a\x02\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__U64(sliding_nonce), TransactionArgument__Address(to_unfreeze_account)],
    )


def encode_unmint_lbr_script(amount_lbr: st.uint64) -> Script:
    """Unmints `amount_lbr` LBR from the sending account into the constituent coins and deposits the resulting coins into the sending account.

    "
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x02\x02\x02\x04\x03\x06\x0f\x05\x15\x10\x07\x25\x65\x08\x8a\x01\x10\x00\x00\x00\x01\x01\x00\x00\x02\x00\x01\x00\x00\x03\x01\x02\x00\x00\x04\x03\x02\x00\x01\x06\x0c\x01\x08\x00\x00\x02\x06\x08\x00\x03\x02\x06\x0c\x03\x0c\x4c\x69\x62\x72\x61\x41\x63\x63\x6f\x75\x6e\x74\x12\x57\x69\x74\x68\x64\x72\x61\x77\x43\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1b\x65\x78\x74\x72\x61\x63\x74\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x1b\x72\x65\x73\x74\x6f\x72\x65\x5f\x77\x69\x74\x68\x64\x72\x61\x77\x5f\x63\x61\x70\x61\x62\x69\x6c\x69\x74\x79\x0c\x75\x6e\x73\x74\x61\x70\x6c\x65\x5f\x6c\x62\x72\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x04\x01\x09\x0b\x00\x11\x00\x0c\x02\x0e\x02\x0a\x01\x11\x02\x0b\x02\x11\x01\x02",
        ty_args=[],
        args=[TransactionArgument__U64(amount_lbr)],
    )


def encode_update_account_limit_definition_script(
    coin_type: TypeTag,
    limit_address: AccountAddress,
    sliding_nonce: st.uint64,
    new_max_inflow: st.uint64,
    new_max_outflow: st.uint64,
    new_max_holding_balance: st.uint64,
    new_time_period: st.uint64,
) -> Script:
    """Optionally update thresholds of max balance, inflow, outflow for any limits-bound accounts with their limits defined at `limit_address`.

    Limits are defined in terms of base (on-chain) currency units for `CoinType`. If a new
    threshold is 0, that particular config does not get updated. `sliding_nonce` is a
    unique nonce for operation, see SlidingNonce.move for details.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x04\x03\x04\x0b\x04\x0f\x02\x05\x11\x19\x07\x2a\x4a\x08\x74\x10\x00\x00\x00\x01\x00\x02\x00\x01\x01\x01\x01\x03\x02\x01\x00\x00\x04\x06\x06\x0c\x05\x03\x03\x03\x03\x00\x02\x06\x0c\x03\x07\x06\x0c\x05\x03\x03\x03\x03\x03\x01\x09\x00\x0d\x41\x63\x63\x6f\x75\x6e\x74\x4c\x69\x6d\x69\x74\x73\x0c\x53\x6c\x69\x64\x69\x6e\x67\x4e\x6f\x6e\x63\x65\x18\x75\x70\x64\x61\x74\x65\x5f\x6c\x69\x6d\x69\x74\x73\x5f\x64\x65\x66\x69\x6e\x69\x74\x69\x6f\x6e\x15\x72\x65\x63\x6f\x72\x64\x5f\x6e\x6f\x6e\x63\x65\x5f\x6f\x72\x5f\x61\x62\x6f\x72\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x03\x01\x0b\x0a\x00\x0a\x02\x11\x01\x0b\x00\x0a\x01\x0a\x03\x0a\x04\x0a\x05\x0a\x06\x38\x00\x02",
        ty_args=[coin_type],
        args=[
            TransactionArgument__Address(limit_address),
            TransactionArgument__U64(sliding_nonce),
            TransactionArgument__U64(new_max_inflow),
            TransactionArgument__U64(new_max_outflow),
            TransactionArgument__U64(new_max_holding_balance),
            TransactionArgument__U64(new_time_period),
        ],
    )


def encode_update_account_limit_window_info_script(
    coin_type: TypeTag, window_address: AccountAddress, aggregate_balance: st.uint64, new_limit_address: AccountAddress
) -> Script:
    """* Sets the account limits window `tracking_balance` field for `CoinType` at `window_address` to `aggregate_balance` if `aggregate_balance != 0`.

    * Sets the account limits window `limit_address` field for `CoinType` at
    `window_address` to `new_limit_address`.
    """
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x02\x03\x02\x06\x04\x08\x02\x05\x0a\x0a\x07\x14\x21\x08\x35\x10\x00\x00\x00\x01\x00\x01\x01\x01\x00\x02\x04\x06\x0c\x05\x03\x05\x00\x01\x09\x00\x0d\x41\x63\x63\x6f\x75\x6e\x74\x4c\x69\x6d\x69\x74\x73\x12\x75\x70\x64\x61\x74\x65\x5f\x77\x69\x6e\x64\x6f\x77\x5f\x69\x6e\x66\x6f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x00\x01\x06\x0b\x00\x0a\x01\x0a\x02\x0a\x03\x38\x00\x02",
        ty_args=[coin_type],
        args=[
            TransactionArgument__Address(window_address),
            TransactionArgument__U64(aggregate_balance),
            TransactionArgument__Address(new_limit_address),
        ],
    )


def encode_update_dual_attestation_limit_script(sliding_nonce: st.uint64, new_micro_lbr_limit: st.uint64) -> Script:
    """Update the dual attesation limit to `new_micro_lbr_limit`."""
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x04\x03\x04\x0a\x05\x0e\x0a\x07\x18\x48\x08\x60\x10\x00\x00\x00\x01\x00\x02\x00\x01\x00\x01\x03\x00\x01\x00\x02\x06\x0c\x03\x00\x03\x06\x0c\x03\x03\x0f\x44\x75\x61\x6c\x41\x74\x74\x65\x73\x74\x61\x74\x69\x6f\x6e\x0c\x53\x6c\x69\x64\x69\x6e\x67\x4e\x6f\x6e\x63\x65\x14\x73\x65\x74\x5f\x6d\x69\x63\x72\x6f\x6c\x69\x62\x72\x61\x5f\x6c\x69\x6d\x69\x74\x15\x72\x65\x63\x6f\x72\x64\x5f\x6e\x6f\x6e\x63\x65\x5f\x6f\x72\x5f\x61\x62\x6f\x72\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x02\x01\x07\x0a\x00\x0a\x01\x11\x01\x0b\x00\x0a\x02\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__U64(sliding_nonce), TransactionArgument__U64(new_micro_lbr_limit)],
    )


def encode_update_exchange_rate_script(
    currency: TypeTag,
    sliding_nonce: st.uint64,
    new_exchange_rate_numerator: st.uint64,
    new_exchange_rate_denominator: st.uint64,
) -> Script:
    """Update the on-chain exchange rate to LBR for the given `currency` to be given by `new_exchange_rate_numerator/new_exchange_rate_denominator`."""
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x07\x01\x00\x06\x02\x06\x04\x03\x0a\x10\x04\x1a\x02\x05\x1c\x19\x07\x35\x64\x08\x99\x01\x10\x00\x00\x00\x01\x00\x02\x00\x00\x02\x00\x00\x03\x00\x01\x00\x02\x04\x02\x03\x00\x01\x05\x04\x03\x01\x01\x02\x06\x02\x03\x03\x01\x08\x00\x02\x06\x0c\x03\x00\x02\x06\x0c\x08\x00\x04\x06\x0c\x03\x03\x03\x01\x09\x00\x0c\x46\x69\x78\x65\x64\x50\x6f\x69\x6e\x74\x33\x32\x05\x4c\x69\x62\x72\x61\x0c\x53\x6c\x69\x64\x69\x6e\x67\x4e\x6f\x6e\x63\x65\x14\x63\x72\x65\x61\x74\x65\x5f\x66\x72\x6f\x6d\x5f\x72\x61\x74\x69\x6f\x6e\x61\x6c\x15\x72\x65\x63\x6f\x72\x64\x5f\x6e\x6f\x6e\x63\x65\x5f\x6f\x72\x5f\x61\x62\x6f\x72\x74\x18\x75\x70\x64\x61\x74\x65\x5f\x6c\x62\x72\x5f\x65\x78\x63\x68\x61\x6e\x67\x65\x5f\x72\x61\x74\x65\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x05\x01\x0b\x0a\x00\x0a\x01\x11\x01\x0a\x02\x0a\x03\x11\x00\x0c\x04\x0b\x00\x0b\x04\x38\x00\x02",
        ty_args=[currency],
        args=[
            TransactionArgument__U64(sliding_nonce),
            TransactionArgument__U64(new_exchange_rate_numerator),
            TransactionArgument__U64(new_exchange_rate_denominator),
        ],
    )


def encode_update_libra_version_script(major: st.uint64) -> Script:
    """Update Libra version."""
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x05\x01\x00\x02\x03\x02\x05\x05\x07\x05\x07\x0c\x11\x08\x1d\x10\x00\x00\x00\x01\x00\x01\x00\x02\x06\x0c\x03\x00\x0c\x4c\x69\x62\x72\x61\x56\x65\x72\x73\x69\x6f\x6e\x03\x73\x65\x74\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x01\x04\x0b\x00\x0a\x01\x11\x00\x02",
        ty_args=[],
        args=[TransactionArgument__U64(major)],
    )


def encode_update_minting_ability_script(currency: TypeTag, allow_minting: st.bool) -> Script:
    """Allows--true--or disallows--false--minting of `currency` based upon `allow_minting`."""
    return Script(
        code=b"\xa1\x1c\xeb\x0b\x01\x00\x00\x00\x06\x01\x00\x02\x03\x02\x06\x04\x08\x02\x05\x0a\x08\x07\x12\x1d\x08\x2f\x10\x00\x00\x00\x01\x00\x01\x01\x01\x00\x02\x02\x06\x0c\x01\x00\x01\x09\x00\x05\x4c\x69\x62\x72\x61\x16\x75\x70\x64\x61\x74\x65\x5f\x6d\x69\x6e\x74\x69\x6e\x67\x5f\x61\x62\x69\x6c\x69\x74\x79\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x01\x01\x00\x01\x04\x0b\x00\x0a\x01\x38\x00\x02",
        ty_args=[currency],
        args=[TransactionArgument__Bool(allow_minting)],
    )
