# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: jsonrpc.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


@dataclass
class Amount(betterproto.Message):
    amount: int = betterproto.uint64_field(1)
    currency: str = betterproto.string_field(2)


@dataclass
class Account(betterproto.Message):
    # hex-encoded bytes
    address: str = betterproto.string_field(1)
    balances: List["Amount"] = betterproto.message_field(2)
    sequence_number: int = betterproto.uint64_field(3)
    # hex-encoded bytes
    authentication_key: str = betterproto.string_field(4)
    # hex-encoded bytes
    sent_events_key: str = betterproto.string_field(5)
    # hex-encoded bytes
    received_events_key: str = betterproto.string_field(6)
    delegated_key_rotation_capability: bool = betterproto.bool_field(7)
    delegated_withdrawal_capability: bool = betterproto.bool_field(8)
    is_frozen: bool = betterproto.bool_field(9)
    role: "AccountRole" = betterproto.message_field(10)


@dataclass
class AccountRole(betterproto.Message):
    type: str = betterproto.string_field(1)
    parent_vasp_address: str = betterproto.string_field(2)
    human_name: str = betterproto.string_field(3)
    base_url: str = betterproto.string_field(4)
    expiration_time: int = betterproto.uint64_field(5)
    # hex-encoded bytes
    compliance_key: str = betterproto.string_field(6)
    # hex-encoded bytes
    compliance_key_rotation_events_key: str = betterproto.string_field(7)
    # hex-encoded bytes
    base_url_rotation_events_key: str = betterproto.string_field(8)
    num_children: int = betterproto.uint64_field(9)
    # hex-encoded bytes
    received_mint_events_key: str = betterproto.string_field(10)
    preburn_balances: List["Amount"] = betterproto.message_field(11)


@dataclass
class Event(betterproto.Message):
    key: str = betterproto.string_field(1)
    sequence_number: int = betterproto.uint64_field(2)
    transaction_version: int = betterproto.uint64_field(3)
    data: "EventData" = betterproto.message_field(4)


@dataclass
class EventData(betterproto.Message):
    type: str = betterproto.string_field(1)
    # burn, cancelburn, mint, preburn, receivedpayment, sentpayment, receivedmint
    # events
    amount: "Amount" = betterproto.message_field(2)
    # burn, cancelburn, preburn events hex-encoded bytes
    preburn_address: str = betterproto.string_field(3)
    # to_xdx_exchange_rate_update event only
    currency_code: str = betterproto.string_field(4)
    new_to_xdx_exchange_rate: float = betterproto.float_field(5)
    # receivedpayment and sentpayment events hex-encoded bytes
    sender: str = betterproto.string_field(6)
    # hex-encoded bytes
    receiver: str = betterproto.string_field(7)
    # hex-encoded bytes
    metadata: str = betterproto.string_field(8)
    # newepoch event only
    epoch: int = betterproto.uint64_field(10)
    # newblock event only
    round: int = betterproto.uint64_field(11)
    # hex-encoded bytes
    proposer: str = betterproto.string_field(12)
    proposed_time: int = betterproto.uint64_field(13)
    # receivedmint event only hex-encoded bytes
    destination_address: str = betterproto.string_field(14)
    # compliancekeyrotation event only hex-encoded bytes
    new_compliance_public_key: str = betterproto.string_field(15)
    # baseurlrotation event only
    new_base_url: str = betterproto.string_field(16)
    # compliancekeyrotation and baseurlrotation events
    time_rotated_seconds: int = betterproto.uint64_field(17)
    # * createaccount event field. Hex-encoded account address bytes of the
    # created account.
    created_address: str = betterproto.string_field(18)
    # * createaccount event field. Role id of the created account, see
    # [DIP-2](https://dip.diem.com/dip-2/#move-implementation) for more details
    role_id: int = betterproto.uint64_field(19)
    # * admintransaction event field. The block time when this transaction is
    # committed. It is created by validators.
    committed_timestamp_secs: int = betterproto.uint64_field(20)


@dataclass
class Metadata(betterproto.Message):
    # * The block (ledger) version
    version: int = betterproto.uint64_field(1)
    # * The block (ledger) timestamp, unit is microsecond
    timestamp: int = betterproto.uint64_field(2)
    # * Chain ID of the Diem network
    chain_id: int = betterproto.uint32_field(3)
    # * List of allowed scripts hex-encoded hash bytes, server may not return
    # this field if the allow list not found in on chain configuration.
    script_hash_allow_list: List[str] = betterproto.string_field(4)
    # * True for allowing publishing customized script, server may not return
    # this field if the flag not found in on chain configuration.
    module_publishing_allowed: bool = betterproto.bool_field(5)
    # * Diem chain major version number.
    diem_version: int = betterproto.uint64_field(6)
    # * accumulator root hash of the ledger version requested
    accumulator_root_hash: str = betterproto.string_field(7)
    # * The dual attestation limit on-chain. Defined in terms of micro-XDX.
    dual_attestation_limit: int = betterproto.uint64_field(8)


@dataclass
class Transaction(betterproto.Message):
    version: int = betterproto.uint64_field(1)
    transaction: "TransactionData" = betterproto.message_field(2)
    hash: str = betterproto.string_field(3)
    # hex-encoded bcs bytes
    bytes: str = betterproto.string_field(4)
    events: List["Event"] = betterproto.message_field(5)
    vm_status: "VMStatus" = betterproto.message_field(6)
    gas_used: int = betterproto.uint64_field(7)


@dataclass
class MoveAbortExplaination(betterproto.Message):
    category: str = betterproto.string_field(1)
    category_description: str = betterproto.string_field(2)
    reason: str = betterproto.string_field(3)
    reason_description: str = betterproto.string_field(4)


@dataclass
class VMStatus(betterproto.Message):
    type: str = betterproto.string_field(1)
    # move_abort, execution_failure
    location: str = betterproto.string_field(2)
    # move_abort only
    abort_code: int = betterproto.uint64_field(3)
    # execution_failure only
    function_index: int = betterproto.uint32_field(4)
    code_offset: int = betterproto.uint32_field(5)
    # move_abort only
    explanation: "MoveAbortExplaination" = betterproto.message_field(6)


@dataclass
class TransactionData(betterproto.Message):
    type: str = betterproto.string_field(1)
    # blockmetadata
    timestamp_usecs: int = betterproto.uint64_field(2)
    # user
    sender: str = betterproto.string_field(3)
    signature_scheme: str = betterproto.string_field(4)
    signature: str = betterproto.string_field(5)
    # hex-encoded bytes
    public_key: str = betterproto.string_field(6)
    sequence_number: int = betterproto.uint64_field(7)
    chain_id: int = betterproto.uint32_field(8)
    max_gas_amount: int = betterproto.uint64_field(9)
    gas_unit_price: int = betterproto.uint64_field(10)
    gas_currency: str = betterproto.string_field(11)
    expiration_timestamp_secs: int = betterproto.uint64_field(12)
    script_hash: str = betterproto.string_field(13)
    # hex-encoded bytes
    script_bytes: str = betterproto.string_field(14)
    script: "Script" = betterproto.message_field(15)


@dataclass
class Script(betterproto.Message):
    # * Name of the script code, see
    # https://github.com/diem/diem/blob/master/language/diem-
    # framework/transaction_scripts/doc/transaction_script_documentation.md for
    # all available script names. Type is set as "unknown" if script code can't
    # be recognized, or transaction payload is not a script. It is possible
    # server side does not know the code and the code is valid.
    type: str = betterproto.string_field(1)
    # * Hex-encoded compiled move script bytes.
    code: str = betterproto.string_field(2)
    # * List of string value of the script arguments. Contains type information.
    # Argument value to string formatting: - u8 value `12` => "{U8: 12}" - u64
    # value `12244` => "{U64: 12244}" - u128 value `12244` => "{U128: 12244}" -
    # boolean value `true` => "{BOOL: true}" - Account address value =>
    # "{ADDRESS: <hex-encoded account address bytes>}" - List<u8> value =>
    # "{U8Vector:: 0x<hex-encoded bytes>}"
    arguments: List[str] = betterproto.string_field(3)
    # * List of type arguments, converted into string.
    type_arguments: List[str] = betterproto.string_field(4)
    # * hex-encoded receiver account address bytes
    receiver: str = betterproto.string_field(5)
    # * peer to peer transfer amount.
    amount: int = betterproto.uint64_field(6)
    # * peer to peer transfer currency code.
    currency: str = betterproto.string_field(7)
    # * Metadata of the transaction, LCS serialized hex-encoded string. See
    # [DIP-4](https://dip.diem.com/dip-4/) for more details.
    metadata: str = betterproto.string_field(8)
    # * Hex-encoded metadata signature, use this to validate metadata. See
    # [DIP-4](https://dip.diem.com/dip-4/) for more details.
    metadata_signature: str = betterproto.string_field(9)


@dataclass
class CurrencyInfo(betterproto.Message):
    code: str = betterproto.string_field(1)
    scaling_factor: int = betterproto.uint64_field(2)
    fractional_part: int = betterproto.uint64_field(3)
    to_xdx_exchange_rate: float = betterproto.float_field(4)
    # hex-encoded bytes
    mint_events_key: str = betterproto.string_field(5)
    # hex-encoded bytes
    burn_events_key: str = betterproto.string_field(6)
    # HEX-encoded bytes
    preburn_events_key: str = betterproto.string_field(7)
    # hex-encoded bytes
    cancel_burn_events_key: str = betterproto.string_field(8)
    # hex-encoded bytes
    exchange_rate_update_events_key: str = betterproto.string_field(9)


@dataclass
class StateProof(betterproto.Message):
    """
    * This is for experimental API get_state_proof response. It is unstable and
    likely to be changed.
    """

    # hex-encoded bcs bytes
    ledger_info_with_signatures: str = betterproto.string_field(1)
    # hex-encoded bcs bytes
    epoch_change_proof: str = betterproto.string_field(2)
    # hex-encoded bcs bytes
    ledger_consistency_proof: str = betterproto.string_field(3)


@dataclass
class AccountStateWithProof(betterproto.Message):
    """
    * This is for experimental API get_account_state_with_proof response. It is
    unstable and likely to be changed.
    """

    version: int = betterproto.uint64_field(1)
    # hex-encoded bcs bytes
    blob: str = betterproto.string_field(2)
    # hex-encoded bcs bytes
    proof: "AccountStateProof" = betterproto.message_field(3)


@dataclass
class AccountStateProof(betterproto.Message):
    """
    * This is for experimental API get_account_state_with_proof response. It is
    unstable and likely to be changed.
    """

    # hex-encoded bcs bytes
    ledger_info_to_transaction_info_proof: str = betterproto.string_field(1)
    # hex-encoded bcs bytes
    transaction_info: str = betterproto.string_field(2)
    # hex-encoded bcs bytes
    transaction_info_to_account_proof: str = betterproto.string_field(3)
